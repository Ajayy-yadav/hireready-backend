<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HireReady AI Interview Test</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
        background: white;
        border-radius: 20px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        overflow: hidden;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 30px;
        text-align: center;
      }

      .header h1 {
        font-size: 2em;
        margin-bottom: 10px;
      }

      .header p {
        opacity: 0.9;
        font-size: 1.1em;
      }

      .content {
        padding: 30px;
      }

      .setup-section {
        margin-bottom: 30px;
      }

      .form-group {
        margin-bottom: 20px;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #333;
      }

      input,
      textarea,
      select {
        width: 100%;
        padding: 12px;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-size: 16px;
        transition: border-color 0.3s;
      }

      input:focus,
      textarea:focus,
      select:focus {
        outline: none;
        border-color: #667eea;
      }

      textarea {
        min-height: 100px;
        resize: vertical;
        font-family: inherit;
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 16px;
        font-weight: 600;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
      }

      button:active {
        transform: translateY(0);
      }

      button:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
      }

      .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
      }

      .status-indicator.connected {
        background: #4caf50;
        box-shadow: 0 0 10px #4caf50;
      }

      .status-indicator.disconnected {
        background: #f44336;
      }

      .interview-section {
        display: none;
      }

      .interview-section.active {
        display: block;
      }

      .progress-bar {
        background: #e0e0e0;
        height: 8px;
        border-radius: 4px;
        margin: 20px 0;
        overflow: hidden;
      }

      .progress-fill {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        height: 100%;
        transition: width 0.3s;
      }

      .question-box {
        background: #f5f5f5;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
        border-left: 4px solid #667eea;
      }

      .question-box h3 {
        color: #667eea;
        margin-bottom: 10px;
      }

      .transcript-box {
        background: #fff;
        border: 2px solid #e0e0e0;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
        min-height: 100px;
        max-height: 200px;
        overflow-y: auto;
      }

      .transcript-box.interim {
        border-color: #ffc107;
        background: #fffbf0;
      }

      .transcript-box.final {
        border-color: #4caf50;
        background: #f1f8f4;
      }

      .logs {
        background: #1e1e1e;
        color: #00ff00;
        padding: 15px;
        border-radius: 10px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        max-height: 300px;
        overflow-y: auto;
        margin-top: 20px;
      }

      .log-entry {
        margin: 5px 0;
        padding: 5px;
      }

      .log-entry.info {
        color: #00ff00;
      }

      .log-entry.success {
        color: #4caf50;
      }

      .log-entry.error {
        color: #f44336;
      }

      .log-entry.warning {
        color: #ffc107;
      }

      .badge {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 12px;
        font-weight: 600;
        margin-left: 10px;
      }

      .badge.recording {
        background: #f44336;
        color: white;
        animation: pulse 1.5s infinite;
      }

      .badge.processing {
        background: #ffc107;
        color: #333;
      }

      .badge.completed {
        background: #4caf50;
        color: white;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .checkmark {
        display: inline-block;
        color: #4caf50;
        font-size: 20px;
        margin-left: 10px;
        animation: fadeIn 0.3s;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.5);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      .audio-visualizer {
        text-align: center;
        padding: 20px;
      }

      .audio-visualizer.active {
        color: #f44336;
        font-weight: 600;
      }

      .completion-screen {
        text-align: center;
        padding: 40px;
      }

      .completion-screen h2 {
        color: #4caf50;
        font-size: 2.5em;
        margin-bottom: 20px;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .stat-card {
        background: #f5f5f5;
        padding: 20px;
        border-radius: 10px;
        text-align: center;
      }

      .stat-card h4 {
        color: #667eea;
        margin-bottom: 10px;
      }

      .stat-card p {
        font-size: 24px;
        font-weight: 600;
        color: #333;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üéØ HireReady AI Interview Test</h1>
        <p>Automatic Flow with UtteranceEnd Detection</p>
        <div style="margin-top: 15px">
          <span class="status-indicator disconnected" id="statusIndicator"></span>
          <span id="statusText">Disconnected</span>
        </div>
      </div>

      <div class="content">
        <!-- Setup Section -->
        <div class="setup-section" id="setupSection">
          <h2 style="margin-bottom: 20px">Setup Interview</h2>

          <div class="form-group">
            <label for="serverUrl">WebSocket Server URL</label>
            <input
              type="text"
              id="serverUrl"
              value="http://localhost:3001/interview"
              placeholder="ws://localhost:3001/interview"
            />
          </div>

          <div class="form-group">
            <label for="userId">User ID</label>
            <input type="text" id="userId" value="test_user_123" placeholder="Enter user ID" />
          </div>

          <div class="form-group">
            <label for="jobDescription">Job Description</label>
            <textarea
              id="jobDescription"
              placeholder="Enter job description..."
            >Senior Full-Stack Developer with expertise in React, Node.js, TypeScript, and PostgreSQL. Must have 5+ years of experience building scalable web applications.</textarea>
          </div>

          <div class="form-group">
            <label for="totalQuestions">Total Questions</label>
            <select id="totalQuestions">
              <option value="3" selected>3 Questions</option>
              <option value="5">5 Questions</option>
              <option value="7">7 Questions</option>
              <option value="10">10 Questions</option>
            </select>
          </div>

          <button onclick="startInterview()" id="startBtn">üöÄ Start Interview</button>
        </div>

        <!-- Interview Section -->
        <div class="interview-section" id="interviewSection">
          <div style="display: flex; justify-content: space-between; align-items: center">
            <h2>Interview in Progress</h2>
            <span id="progressText">Question 0/0</span>
          </div>

          <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
          </div>

          <div class="question-box" id="questionBox">
            <h3>Current Question</h3>
            <p id="questionText">Waiting for question...</p>
          </div>

          <div class="audio-visualizer" id="audioVisualizer">
            <span id="recordingStatus">üé§ Ready to record</span>
          </div>

          <div style="margin: 20px 0">
            <h4>Your Answer (Real-time Transcript)</h4>
            <div class="transcript-box" id="transcriptBox">
              <p id="transcriptText" style="color: #999">Start speaking to see transcript...</p>
            </div>
            <div style="text-align: right">
              <span id="saveIndicator"></span>
            </div>
          </div>

          <div style="text-align: center; margin: 20px 0">
            <button onclick="manualFinish()" id="finishBtn" style="background: #ffc107">
              üìù Finish Answer (Manual Fallback)
            </button>
          </div>
        </div>

        <!-- Completion Section -->
        <div class="interview-section" id="completionSection">
          <div class="completion-screen">
            <h2>üéâ Interview Completed!</h2>
            <p style="font-size: 1.2em; color: #666; margin-bottom: 30px">
              Great job! Your interview has been successfully recorded.
            </p>

            <div class="stats">
              <div class="stat-card">
                <h4>Session ID</h4>
                <p id="sessionIdStat" style="font-size: 14px">-</p>
              </div>
              <div class="stat-card">
                <h4>Questions Answered</h4>
                <p id="questionsAnswered">0/0</p>
              </div>
              <div class="stat-card">
                <h4>Status</h4>
                <p id="completionStatus" style="color: #4caf50">‚úì Complete</p>
              </div>
            </div>

            <button onclick="resetTest()" style="margin-top: 20px">üîÑ Start New Interview</button>
          </div>
        </div>

        <!-- Logs -->
        <h3 style="margin-top: 30px">Event Logs</h3>
        <div class="logs" id="logs"></div>
      </div>
    </div>

    <script>
      let socket = null;
      let mediaRecorder = null;
      let audioStream = null;
      let sessionId = null;
      let currentQuestion = 0;
      let totalQuestions = 0;
      let isRecording = false;

      // Add log entry
      function log(message, type = 'info') {
        const logs = document.getElementById('logs');
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logs.appendChild(entry);
        logs.scrollTop = logs.scrollHeight;
      }

      // Update connection status
      function updateStatus(connected) {
        const indicator = document.getElementById('statusIndicator');
        const text = document.getElementById('statusText');
        if (connected) {
          indicator.className = 'status-indicator connected';
          text.textContent = 'Connected';
          log('‚úÖ Connected to WebSocket server', 'success');
        } else {
          indicator.className = 'status-indicator disconnected';
          text.textContent = 'Disconnected';
          log('‚ùå Disconnected from server', 'error');
        }
      }

      // Connect to WebSocket
      function connectWebSocket(url) {
        socket = io(url, {
          transports: ['websocket'],
        });

        socket.on('connect', () => {
          updateStatus(true);
        });

        socket.on('disconnect', () => {
          updateStatus(false);
        });

        // Interview started
        socket.on('interview_started', (data) => {
          log(`üéØ Interview started! Session: ${data.sessionId}`, 'success');
          sessionId = data.sessionId;
          currentQuestion = data.currentQuestion;
          totalQuestions = data.totalQuestions;

          document.getElementById('setupSection').classList.remove('active');
          document.getElementById('interviewSection').classList.add('active');

          displayQuestion(data.content);
          updateProgress();
        });

        // Question audio
        socket.on('question_audio', async (data) => {
          log(`üîä Received question audio (${data.audio.length} bytes)`, 'info');

          // Play audio
          try {
            const audioBlob = base64ToBlob(data.audio, 'audio/wav');
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);

            audio.onplay = () => {
              log('‚ñ∂Ô∏è Playing question audio...', 'info');
              document.getElementById('recordingStatus').textContent = 'üîä Playing question...';
            };

            audio.onended = () => {
              log('‚úÖ Question audio finished - auto-starting recording', 'success');
              startRecording();
            };

            await audio.play();
          } catch (error) {
            log(`‚ùå Error playing audio: ${error.message}`, 'error');
            // Start recording anyway
            startRecording();
          }
        });

        // Interim transcript
        socket.on('interim_transcript', (data) => {
          const transcriptBox = document.getElementById('transcriptBox');
          const transcriptText = document.getElementById('transcriptText');

          transcriptText.textContent = data.content || 'Listening...';

          if (data.isFinal) {
            transcriptBox.className = 'transcript-box final';
            log(`üìù Final transcript: "${data.content}"`, 'success');
          } else {
            transcriptBox.className = 'transcript-box interim';
          }
        });

        // Answer saved
        socket.on('answer_saved', () => {
          log('üíæ Answer saved automatically', 'success');
          const indicator = document.getElementById('saveIndicator');
          indicator.innerHTML = '<span class="checkmark">‚úì Saved</span>';
          setTimeout(() => {
            indicator.innerHTML = '';
          }, 2000);
        });

        // Next question
        socket.on('next_question', (data) => {
          log(`‚ùì Next question: "${data.content.substring(0, 50)}..."`, 'info');
          currentQuestion = data.currentQuestion;
          displayQuestion(data.content);
          updateProgress();

          // Clear transcript for next answer
          const transcriptBox = document.getElementById('transcriptBox');
          const transcriptText = document.getElementById('transcriptText');
          transcriptBox.className = 'transcript-box';
          transcriptText.textContent = 'Start speaking to see transcript...';
          transcriptText.style.color = '#999';
          
          // Don't stop recording - it continues automatically!
          log('üé§ Recording continues for next question...', 'info');
        });

        // Interview completed
        socket.on('interview_completed', (data) => {
          log('üéâ Interview completed!', 'success');
          stopRecording();

          document.getElementById('interviewSection').classList.remove('active');
          document.getElementById('completionSection').classList.add('active');

          document.getElementById('sessionIdStat').textContent = sessionId;
          document.getElementById('questionsAnswered').textContent = `${data.currentQuestion || totalQuestions}/${totalQuestions}`;
        });

        // Silence timeout
        socket.on('silence_timeout', () => {
          log('‚è±Ô∏è 10-second silence detected - interview auto-completing', 'warning');
        });

        // Error
        socket.on('interview_error', (data) => {
          log(`‚ùå Error: ${data.error}`, 'error');
          alert(`Error: ${data.error}`);
        });
      }

      // Start interview
      function startInterview() {
        const serverUrl = document.getElementById('serverUrl').value;
        const userId = document.getElementById('userId').value;
        const jobDescription = document.getElementById('jobDescription').value;
        const totalQuestionsValue = parseInt(document.getElementById('totalQuestions').value);

        if (!userId || !jobDescription) {
          alert('Please fill in all fields');
          return;
        }

        log('üöÄ Starting interview...', 'info');

        // Connect to WebSocket
        if (!socket || !socket.connected) {
          connectWebSocket(serverUrl);

          // Wait for connection before starting
          setTimeout(() => {
            if (socket.connected) {
              socket.emit('start_interview', {
                userId,
                jobDescription,
                totalQuestions: totalQuestionsValue,
              });
            } else {
              alert('Failed to connect to server. Please check the URL.');
            }
          }, 500);
        } else {
          socket.emit('start_interview', {
            userId,
            jobDescription,
            totalQuestions: totalQuestionsValue,
          });
        }
      }

      // Start recording (reuses existing stream after first time)
      async function startRecording() {
        try {
          // If already recording, just resume
          if (isRecording && mediaRecorder && mediaRecorder.state === 'recording') {
            log('üé§ Already recording, continuing...', 'info');
            return;
          }

          // Request mic permission only if we don't have a stream yet
          if (!audioStream) {
            log('üé§ Requesting microphone access...', 'info');
            
            audioStream = await navigator.mediaDevices.getUserMedia({ 
              audio: {
                channelCount: 1,
                sampleRate: 16000,
                echoCancellation: true,
                noiseSuppression: true,
              }
            });

            log('‚úÖ Microphone access granted', 'success');
          } else {
            log('üé§ Reusing existing microphone stream', 'info');
          }

          // Create new MediaRecorder only if needed
          if (!mediaRecorder || mediaRecorder.state === 'inactive') {
            // Check if browser supports the audio/webm format that Deepgram can handle
            let mimeType = 'audio/webm;codecs=opus';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
              log('‚ö†Ô∏è audio/webm not supported, trying alternatives...', 'warning');
              // Try other formats
              const alternatives = [
                'audio/webm',
                'audio/ogg;codecs=opus',
                'audio/mp4',
                ''
              ];
              for (const alt of alternatives) {
                if (MediaRecorder.isTypeSupported(alt)) {
                  mimeType = alt;
                  log(`‚úÖ Using format: ${alt || 'default'}`, 'info');
                  break;
                }
              }
            } else {
              log(`‚úÖ Using format: ${mimeType}`, 'info');
            }

            mediaRecorder = new MediaRecorder(audioStream, {
              mimeType: mimeType || undefined
            });

            mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                const reader = new FileReader();
                reader.onloadend = () => {
                  const base64Audio = reader.result.split(',')[1];
                  socket.emit('audio_chunk', { audio: base64Audio });
                };
                reader.readAsDataURL(event.data);
              }
            };

            mediaRecorder.start(250); // Send chunks every 250ms
            isRecording = true;

            document.getElementById('recordingStatus').innerHTML =
              'üî¥ Recording... <span class="badge recording">LIVE</span>';
            log('‚úÖ Recording started - speak now!', 'success');
            log('‚è±Ô∏è Will auto-process after 2s pause', 'info');
          } else if (mediaRecorder.state === 'paused') {
            mediaRecorder.resume();
            isRecording = true;
            log('‚ñ∂Ô∏è Recording resumed', 'success');
          }
        } catch (error) {
          log(`‚ùå Microphone error: ${error.message}`, 'error');
          alert('Please allow microphone access to continue');
        }
      }

      // Stop recording (for final completion only - don't close stream between questions)
      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
          log('‚èπÔ∏è Recording stopped', 'info');
        }

        if (audioStream) {
          audioStream.getTracks().forEach((track) => track.stop());
          audioStream = null; // Clear stream reference
        }

        isRecording = false;
        mediaRecorder = null;

        document.getElementById('recordingStatus').textContent = 'üé§ Recording stopped';
      }

      // Manual finish (fallback)
      function manualFinish() {
        log('üìù Manual finish triggered', 'warning');
        socket.emit('finish_recording');
        stopRecording();
      }

      // Display question
      function displayQuestion(question) {
        document.getElementById('questionText').textContent = question;
      }

      // Update progress
      function updateProgress() {
        document.getElementById('progressText').textContent = `Question ${currentQuestion}/${totalQuestions}`;
        const percentage = (currentQuestion / totalQuestions) * 100;
        document.getElementById('progressFill').style.width = `${percentage}%`;
      }

      // Convert base64 to blob
      function base64ToBlob(base64, mimeType) {
        const byteCharacters = atob(base64);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        return new Blob([byteArray], { type: mimeType });
      }

      // Reset test
      function resetTest() {
        if (socket) {
          socket.disconnect();
          socket = null;
        }
        stopRecording();

        document.getElementById('setupSection').classList.add('active');
        document.getElementById('interviewSection').classList.remove('active');
        document.getElementById('completionSection').classList.remove('active');

        sessionId = null;
        currentQuestion = 0;
        totalQuestions = 0;
        isRecording = false;

        log('üîÑ Test reset - ready for new interview', 'info');
      }

      // Initialize
      window.onload = () => {
        document.getElementById('setupSection').classList.add('active');
        log('‚úÖ Test interface loaded', 'success');
        log('üìù Configure settings and click "Start Interview"', 'info');
      };
    </script>
  </body>
</html>

